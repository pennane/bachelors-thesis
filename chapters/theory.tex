% Theoretical background
%\clearpage % Uncomment if needed to force a page break before the chapter
\vspace{21.5pt}
\chapter{Teoreettinen tausta}

Jotta voidaan tutkia sitä, miten funktionaalinen ohjelmointi vaikuttaa ohjelmointiin \gls{ts} ympäristössä, on kartoitettava mitä ylipäätään funktionaalinen ohjelmointi on kieliagnostisesti. Tämän jälkeen voidaan tarkastella miten funktionaalinen ohjelmointi on näkynyt \gls{ts} projekteissa, ja lopuksi voidaan vertailla mikä osa tästä on kategorisesti funktionaalista, mikä olio-ohjelmallista, tai pelkästään proseduaalista.

Näillä tiedoilla voidaan lähteä tutkimaan miten käytänteet näkyvät hyödyllisesti tai haitallisesti ohjelmistoprojekteissa, joissa halutaan käyttää funktionaalista ohjelmointia pragmaattisesti.

\section{Funktionaalinen ohjelmointi}

TODO

Nopea historia, lambdakalkyyli ja kombinaattorit (Kuva \ref{code:javascript_combinators}). Olennaiset asiat. Immutability ja "pure function"

\begin{code}
  \begin{minted}{javascript}
const I  = x => x
const K  = x => y => x
const A  = f => x => f (x)
const T  = x => f => f (x)
const W  = f => x => f (x) (x)
const C  = f => y => x => f (x) (y)
const B  = f => g => x => f (g (x))
const S  = f => g => x => f (x) (g (x))
const S_ = f => g => x => f (g (x)) (x)
const S2 = f => g => h => x => f (g (x)) (h (x))
\end{minted}
  \caption{Yleiset kombinaattorit esitettynä JavaScriptissä \cite{javascript_combinators}}
  \label{code:javascript_combinators}
\end{code}

TODO

\subsection{Yhdistefunktiot ja niiden merkitys}

Funktionaalinen ohjelmointi on pääasiassa vain ja ainoastaan funktioiden yhdistämistä tai koostamista.


TODO

\begin{code}
  \begin{equation}
    f(x) = 2x
  \end{equation}
  \begin{equation}
    g(x) = x + 3
  \end{equation}
  \begin{equation}
    h(x) = f(g(x)) = 2(x + 3) = 2x + 6
  \end{equation}
  \caption{Matemaattinen esimerkki funktiokompositiosta}
  \label{equation:composition}
\end{code}
\bigskip

\begin{code}
  \begin{minted}{haskell}
f :: Int -> Int
f x = 2 * x

g :: Int -> Int
g x = x + 3

h :: Int -> Int
h x = f (g x)
\end{minted}
  \caption{Haskell-esimerkki funktiokompositiosta}
  \label{code:haskell_composition}
\end{code}
\bigskip
\begin{code}
  \begin{minted}{javascript}
function f(x) {
  return 2 * x;
}

function g(x) {
  return x + 3;
}

function h(x) {
  return f(g(x));
}
\end{minted}
  \caption{JavaScript-esimerkki funktiokompositiosta}
  \label{code:javascript_composition}
\end{code}


\subsection{Joukko-oppi}

TODO

Pari idistä siitä, että joukko-oppia pitäisi ajatella aina. Ei vain funktionaalista ohjelmointia harjoittaessa.
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}
    % Ellipses for sets A, B, and C with background colors
    \draw[thick, ellipse, fill=green!20] (0,0.5) ellipse (0.8cm and 2cm);  % Set A with light blue background
    \draw[thick, ellipse, fill=blue!20] (3,0.5) ellipse (0.8cm and 2cm); % Set B with light green background
    \draw[thick, ellipse, fill=red!20] (6,0.5) ellipse (0.8cm and 2cm);   % Set C with light red background

    % Nodes for set A (without borders)
    \node[draw=none] (A1) at (0,2) {1};
    \node[draw=none] (A2) at (0,1) {2};
    \node[draw=none] (A3) at (0,0) {3};
    \node[draw=none] (A4) at (0,-1) {4};

    % Nodes for set B (without borders)
    \node[draw=none] (B1) at (3,2) {1};
    \node[draw=none] (B2) at (3,1) {2};
    \node[draw=none] (B3) at (3,0) {3};
    \node[draw=none] (B4) at (3,-1) {4};

    % Nodes for set C (without borders)
    \node[draw=none] (C1) at (6,2) {1};
    \node[draw=none] (C2) at (6,1) {2};
    \node[draw=none] (C3) at (6,0) {3};
    \node[draw=none] (C4) at (6,-1) {4};

    % Arrows from A to B
    \draw[->] (A1) -- (B1);
    \draw[->] (A2) -- (B3);
    \draw[->] (A3) -- (B2);
    \draw[->] (A4) -- (B4);

    % Arrows from B to C
    \draw[->] (B1) -- (C2);
    \draw[->] (B2) -- (C1);
    \draw[->] (B3) -- (C3);
    \draw[->] (B4) -- (C4);

    % Labels for sets
    \node[draw=none, text=green!50!black] at (0,3) {$A = \{1,2,3,4\}$};
    \node[draw=none, text=blue] at (3,3) {$B = \{1,2,3,4\}$};
    \node[draw=none, text=red] at (6,3) {$C = \{1,2,3,4\}$};

    % Arrow to new diagram
    \draw[->, line width=1.5mm, black] (3,-1.75) -- (3,-2.75) node[midway, right] {};

    % New diagram with direct A to C composition
    % Ellipses for sets A and C below the original picture
    \draw[thick, ellipse, fill=green!20] (0,-4.5) ellipse (0.8cm and 2cm);  % Set A with light blue background
    \draw[thick, ellipse, fill=red!20] (6,-4.5) ellipse (0.8cm and 2cm);   % Set C with light red background

    % Nodes for set A (without borders) - Lower position
    \node[draw=none] (A1b) at (0,-3) {1};
    \node[draw=none] (A2b) at (0,-4) {2};
    \node[draw=none] (A3b) at (0,-5) {3};
    \node[draw=none] (A4b) at (0,-6) {4};

    % Nodes for set C (without borders) - Lower position
    \node[draw=none] (C1b) at (6,-3) {1};
    \node[draw=none] (C2b) at (6,-4) {2};
    \node[draw=none] (C3b) at (6,-5) {3};
    \node[draw=none] (C4b) at (6,-6) {4};

    % Direct arrows from A to C (composition)
    \draw[->] (A1b) -- (C2b);
    \draw[->] (A2b) -- (C3b);
    \draw[->] (A3b) -- (C1b);
    \draw[->] (A4b) -- (C4b);

  \end{tikzpicture}
  \caption{Funktioiden yhdistäminen joukko-opin näkökulmasta. Funktiot f : A$\,\to\,$B ja g : B$\,\to\,$C yhdistämällä saadaan g : A$\,\to\,$C.}
\end{figure}


Kelaa mitkä chancet tehä juttuja tehokkaaksi fiksulla kääntäjällä! Voidaan poistaa turhaa laskentaa.

\subsection{Kategoriateoria}

\Gls{category_theory} on kreisi.

TODO

Pari idistä siitä, mitä hyötyy kun lähtee syvään päähänn. Toisaalta myös se, että miten sinne edes pääsee ja miten sen voi erottaa.

\section{Tyypitys}

TODO

Tyypitys on todella tärkeää. Tyypit ohjaavat koodia ja estävät vääriä tiloja ohjemakoodin kääntämisvaiheessa.

TODO Mites \gls{js} :D



\subsection{Parametrinen polymorfismi}

TODO

Haskelille ominaista, \gls{fp} ominaista.


\subsection{Hindley-Milner tyyppijärjestelmä}

TODO

Feldmanin mukaan, mahdottomat tilat ovat testausta parempaa \cite{impossiblebetter}.

Myös Dijkstran idis abstraktiosta sopii kauniisti tähän, ja esimerkki siitä et mitä \gls{fp} on parhaimmillaan.

Parametrinen polymorfismi näkyy täs myös.

\section{Pragmaattisuus}

TODO

Kun funktionaalisen ohjelmoinnin kauneus on matemaattisissa kulmakivissä jotka eivät taivu, miten sitä voi yhdistää nykymaailman pikakoodaukseen? Python, \gls{ts} yms. Chat gpt? Miten se edes osaa kirjoittaa fp koodia :D

TODO miten uncle bob sanoo? \cite{martin2017pragmaticfp}

\subsection{A monad is a monoid in the category of endofunctors}

TODO

Hyvää bäntteriä siitä, miksei fp ole lähtenyt lentoon, miksi pragmaattisuus on hot. Miten fp näkyy nykymaailmassa ja miten se mielletään. Pohja kategoriateoriassa pelottaa.

Nopea kattaus \textquote{developer advocate} -heppujen mielipiteistä.

Viittaus Promise-spesifikaation monadittomuuteen, mainitaan myös alempana

\subsection{Funktionaalisen ohjelmoinnin ripottelu}

TODO

Idiksiä siitä että juuri otetaan funktionaalisen ohjemoinnin parhaat palat

Youtube videoista konkreettisia esimerkkejä.

\section{Funktionaalinen ohjelmointi \& Typescript}


TODO

Typescriptiä tullaan käyttämään insinöörityön koodiesimerkeissä, niin on aiheellista näyttää miten Typescriptissä \gls{fp} näkyy.

TODO TypeScript tyypit HYVÄ! Rich Hickey tykkää myös, voi tehä "product type" tms

Toisaalta TS -> overhead, välillä joutuu kikkailemaan

\subsection{Promise-tietorakenne ja osittaismonadisuus}

Promise ei ole monadi :( \cite{read-it-later-11481,promises-spec-94}

Se ei ole monadi, koska \gls{js} spesifikaatiota määriteltäessä ei päästy yhteisymmärrykseen siitä, että Promise-tietorakenteen tulisi olla monadi. Syy on moniuloitteinen, mutta pääasiallisesti sivuaa sitä, että funktionaalinen ohjelmointi ja sen käsitteet ovat vaikeita selittää kohtuullisella tarkkuudella. \citep{promises-spec-94}

Tämä kirjoitushetkellä jo yli kymmenen vuotta sitten tehty päätös heikensi merkittävästi \gls{js}:n mahdollisuuksia viedä funktionaalista ohjelmointia eteenpäin. \Gls{js} kielenä on laajuudeltaan ongelmallinen. Uusia ominaisuuksia ei voi lisätä, jos vastaavanlaisia ominaisuuksia on aiemmin ollut osana suosittuja \gls{js}-kirjastoja \cite{proposal-joint-iteration,prototype_library_trends}.

TODO lisää siitä että ei tulla ikinä saamaan "builtin" monadeja
TODO myös että no mitä se tarkoittaa, onko juuri promisen kannalta mitään merkitystä

\subsection{Ramda.js}

Koska funktionaalisen ohjelmakoodin tuottaminen \gls{js} tai \gls{ts} ympäristössä enemmän tai vähemmän vaatii jotain kirjastoa, joko itse ohjelmoitua tai ulkoista, niin tähän insinöörityöhön on kirjastoksi valittu Ramda.js.

Ramda.js, ja kirjaston taustalla oleelinen Fantasy Land -algebrallinen spesifikaatio, ovat kirjastoja jotka pyrkivät johdonmukaiseen funktionaaliseen ohjelmointiin JavaScriptissä. Näiden kirjastojen kehittäjistöstä löytyy samoja henkilöitä jotka aikoinaan pyrkivät saamaan Promise-tietorakenteen virallisesti monadiseksi \cite{ramda:contributors,fantasy-land:contributors,promises-spec-94}. Näyttää siltä, että kun tähän tavoitteeseen ei päästy, päättivät kehittäjät tuoda funktionaalisen ohjelmoinnin JavaScriptiin omin keinoin.

TODO miten ramda toimii

TODO miten ramda sopii omien funktioiden kanssa

TODO miten typescript? ei hyvä, tyypit ovat mitä sattuu (kokemuspohjaisesti)

\subsection{Rajoitteet}

TODO

Mitkä asiat eivät ole mahdollisia, tai mitkä ovat erittäin hankalia / järjettömiä kun ohjelmoidaan \gls{fp} koodia \gls{ts}-maailmassa.


\section{Vertailu yhteenvetona}

TODO

Ehkä nopea yhteenveto että mikä on täysin \gls{fp} ominaista ja mikä ei. Mahdollisesti jokin kiva taulukko.