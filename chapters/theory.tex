% Theoretical background
%\clearpage % Uncomment if needed to force a page break before the chapter
\vspace{21.5pt}
\chapter{Teoreettinen tausta}

Jotta voidaan tutkia sitä, miten funktionaalinen ohjelmointi vaikuttaa ohjelmointiin \gls{ts} ympäristössä, on kartoitettava mitä ylipäätään funktionaalinen ohjelmointi on.

Teoriaosuudessa pyritään avaamaan funktionaalisen ohjelmoinnin perusteet \glsdisp{language_agnostic}{kieliagnostisesti}, ja toisaalta myös JavaScript- sekä TypeScript-ekosysteemien kannalta.

Teoriaosuuden lopussa pohjustuksen jälkeen voidaan vielä vertailla sitä, miten funktionaalinen ohjelmointi, olio-ohjelmointi, tai proseduaalinen ohjelmointi eroavat käytännössä.

Lopulta näillä tiedoilla voidaan lähteä tutkimaan miten funktionaalisen ohjelmoinnin käytänteet näkyvät hyödyllisesti tai haitallisesti ohjelmistoprojekteissa.

\section{Funktionaalinen ohjelmointi}

Funktionaalinen ohjelmointi on ohjelmointiparadigma, jonka juuret ulottuvat 1930-luvulle ja lambda-kalkyylin kehitykseen. Lähestymistapa korostaa funktioiden käyttöä perusyksikköinä ja pyrkii välttämään muuttuvia tiloja sekä sivuvaikutuksia. Funktionaalisen ohjelmoinnin keskeisiä käsitteitä ovat \glsdisp{pure_function}{puhtaat funktiot}, \glsdisp{higher_order_function}{korkeamman asteen funktiot}, \gls{immutable_data} sekä \gls{declarative_programming}. \citep{Tan2004,computerphile_lambda}


Funktionaalinen ohjelmointi mahdollistaa koodin uudelleenkäytettävyyden. Lambda-kalkyylin perustein jokaikisen ongelman voi purkaa pieniksi funktioiksi. \citep{BlellochHarper2015} Lambda-kalkyylin voi ajatella olevan esoteerinen ohjelmointikieli. Sen voi kuitenkin myös ottaa osaksi ohjelmoijan työkalupakkia missä tahansa ohjelmointikielessä, joka kohtelee funktioita ensiluokkaisina, eli siten, että niitä voi käyttää muuttujina (Koodiesimerkki \ref{code:javascript_combinators}). Kombinaattorit ovat omalla tavallaan sitä, mitä suunnittelumallit ovat olio-ohjelmoinnissa: tapa ratkaista ongelmia yleisesti ja siten, että siitä voidaan keskustella.

\begin{code}
	\begin{minted}{javascript}
const identity      = x => x
const constant      = x => y => x
const apply         = f => x => f (x)
const thrush        = x => f => f (x)
const duplication   = f => x => f (x) (x)
const flip          = f => y => x => f (x) (y)
const compose       = f => g => x => f (g (x))
const substitution  = f => g => x => f (x) (g (x))

\end{minted}
	\caption{Yleiset kombinaattorit esitettynä JavaScriptissä \cite{javascript_combinators}. Kombinaattoreilla voi esittäää lambda-kalkyyliä, ja ohjelmoida Turing-vahvoja ohjelmia.}
	\label{code:javascript_combinators}
\end{code}

Kombinaattorit näyttävät uhkaviilta ja raa'assa muodossaan niiden hyötyarvoa voi olla hankala havaita. Niiden käyttämistä voi kuitenkin perustella niidein niiden perustavanlaatuisten ja kieliagnostisien ominaisuuksien takia. Ohjelmoidessa funktionaalisesti ei kombinaattoreita tarvitse ajatella. Niitä tulee kirjoittamaan varmasti vähintään vahingossa, sillä niitä vaaditaan funktioita pyörittäessä. On hyvä tiedostaa käytössä olevat rakennuspalikat, ja millä nimellä etsiä niistä tietoa tarvittaessa.

\subsection{Yhdistefunktiot ja niiden vahva merkitys}

Vaikka usein funktionaalista ohjelmointia mainostaessa puhutaan funktioiden puhtauden ja datan muuttumattomuuden olevan kaikista oleellisinta, on tälle myöskin vaihtoehtoinen mielipide. blaah blaah :D

Funktionaalinen ohjelmointi on pääasiassa vain ja ainoastaan funktioiden yhdistämistä tai koostamista.



TODO

\begin{code}
	\begin{equation}
		f(x) = 2x
	\end{equation}
	\begin{equation}
		g(x) = x + 3
	\end{equation}
	\begin{equation}
		h(x) = f(g(x)) = 2(x + 3) = 2x + 6
	\end{equation}
	\caption{Matemaattinen esimerkki funktiokompositiosta}
	\label{equation:composition}
\end{code}
\bigskip

\begin{code}
	\begin{minted}{haskell}
f :: Int -> Int
f x = 2 * x

g :: Int -> Int
g x = x + 3

h :: Int -> Int
h x = f (g x)
\end{minted}
	\caption{Haskell-esimerkki funktiokompositiosta}
	\label{code:haskell_composition}
\end{code}
\bigskip
\begin{code}
	\begin{minted}{javascript}
const f = x => 2 * x;

const g = x => x + 3;

const h = x => f(g(x))
\end{minted}
	\caption{JavaScript-esimerkki funktiokompositiosta ilman pipe-funktiota}
	\label{code:javascript_composition}
\end{code}


\subsection{Joukko-oppi}

TODO

Pari idistä siitä, että joukko-oppia pitäisi ajatella aina. Ei vain funktionaalista ohjelmointia harjoittaessa.
\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}
		% Ellipses for sets A, B, and C with background colors
		\draw[thick, ellipse, fill=green!20] (0,0.5) ellipse (0.8cm and 2cm);  % Set A with light blue background
		\draw[thick, ellipse, fill=blue!20] (3,0.5) ellipse (0.8cm and 2cm); % Set B with light green background
		\draw[thick, ellipse, fill=red!20] (6,0.5) ellipse (0.8cm and 2cm);   % Set C with light red background

		% Nodes for set A (without borders)
		\node[draw=none] (A1) at (0,2) {1};
		\node[draw=none] (A2) at (0,1) {2};
		\node[draw=none] (A3) at (0,0) {3};
		\node[draw=none] (A4) at (0,-1) {4};

		% Nodes for set B (without borders)
		\node[draw=none] (B1) at (3,2) {1};
		\node[draw=none] (B2) at (3,1) {2};
		\node[draw=none] (B3) at (3,0) {3};
		\node[draw=none] (B4) at (3,-1) {4};

		% Nodes for set C (without borders)
		\node[draw=none] (C1) at (6,2) {1};
		\node[draw=none] (C2) at (6,1) {2};
		\node[draw=none] (C3) at (6,0) {3};
		\node[draw=none] (C4) at (6,-1) {4};

		% Arrows from A to B
		\draw[->] (A1) -- (B1);
		\draw[->] (A2) -- (B3);
		\draw[->] (A3) -- (B2);
		\draw[->] (A4) -- (B4);

		% Arrows from B to C
		\draw[->] (B1) -- (C2);
		\draw[->] (B2) -- (C1);
		\draw[->] (B3) -- (C3);
		\draw[->] (B4) -- (C4);

		% Labels for sets
		\node[draw=none, text=green!50!black] at (0,3) {$A = \{1,2,3,4\}$};
		\node[draw=none, text=blue] at (3,3) {$B = \{1,2,3,4\}$};
		\node[draw=none, text=red] at (6,3) {$C = \{1,2,3,4\}$};

		% Arrow to new diagram
		\draw[->, line width=1.5mm, black] (3,-1.75) -- (3,-2.75) node[midway, right] {};

		% New diagram with direct A to C composition
		% Ellipses for sets A and C below the original picture
		\draw[thick, ellipse, fill=green!20] (0,-4.5) ellipse (0.8cm and 2cm);  % Set A with light blue background
		\draw[thick, ellipse, fill=red!20] (6,-4.5) ellipse (0.8cm and 2cm);   % Set C with light red background

		% Nodes for set A (without borders) - Lower position
		\node[draw=none] (A1b) at (0,-3) {1};
		\node[draw=none] (A2b) at (0,-4) {2};
		\node[draw=none] (A3b) at (0,-5) {3};
		\node[draw=none] (A4b) at (0,-6) {4};

		% Nodes for set C (without borders) - Lower position
		\node[draw=none] (C1b) at (6,-3) {1};
		\node[draw=none] (C2b) at (6,-4) {2};
		\node[draw=none] (C3b) at (6,-5) {3};
		\node[draw=none] (C4b) at (6,-6) {4};

		% Direct arrows from A to C (composition)
		\draw[->] (A1b) -- (C2b);
		\draw[->] (A2b) -- (C3b);
		\draw[->] (A3b) -- (C1b);
		\draw[->] (A4b) -- (C4b);

	\end{tikzpicture}
	\caption{Funktioiden yhdistäminen joukko-opin näkökulmasta. Funktiot f : A$\,\to\,$B ja g : B$\,\to\,$C yhdistämällä saadaan g : A$\,\to\,$C.}
\end{figure}


Kelaa mitkä chancet tehä juttuja tehokkaaksi fiksulla kääntäjällä! Voidaan poistaa turhaa laskentaa.

\subsection{Kategoriateoria}

\Gls{category_theory} on kreisi.

TODO

Pari idistä siitä, mitä hyötyy kun lähtee syvään päähänn. Toisaalta myös se, että miten sinne edes pääsee ja miten sen voi erottaa.


\section{Tyypitys}

TODO

Tyypitys on todella tärkeää. Tyypit ohjaavat koodia ja estävät vääriä tiloja ohjemakoodin kääntämisvaiheessa. Tyypeillä pidetään ohjelmoija niissä raameissa, mitä funktionaalinen ohjelmointi usein vaatii \cite[44]{cantarella_fp_haitat}.

JavaScriptissä tyypit eivät näy ohjelmoijalle muuten kuin sillon, kun ohjelma räjähtää ajon aikana. TypeScriptissä tyypit tulevat tielle. Haskelissa (ja PHP:ssa)

TODO Mites \gls{js} :D

\subsection{Staattinen ja dynaaminen tyypitys}

TODO

\subsection{Nimellinen ja rakenteellinen tyypitys}


\subsection{Parametrinen polymorfismi}

TODO

Haskelille ominaista, \gls{fp} ominaista.


\subsection{Hindley-Milner tyyppijärjestelmä}

TODO

Feldmanin mukaan, mahdottomat tilat ovat testausta parempaa \cite{impossiblebetter}.

Myös Dijkstran idis abstraktiosta sopii kauniisti tähän, ja esimerkki siitä et mitä \gls{fp} on parhaimmillaan.

Parametrinen polymorfismi näkyy täs myös.


\section{Pragmaattisuus}

TODO

Kun funktionaalisen ohjelmoinnin kauneus on matemaattisissa kulmakivissä jotka eivät taivu, miten sitä voi yhdistää nykymaailman pikakoodaukseen? Python, \gls{ts} yms. Chat gpt? Miten se edes osaa kirjoittaa fp koodia :D

TODO miten uncle bob sanoo? \cite{martin2017pragmaticfp}

\subsection{Monadi on monoidi endofunktorien kategoriassa}

TODO

Hyvää bäntteriä siitä, miksei fp ole lähtenyt lentoon, miksi pragmaattisuus on hot. Miten fp näkyy nykymaailmassa ja miten se mielletään. Pohja kategoriateoriassa pelottaa.

Nopea kattaus \textquote{developer advocate} -heppujen mielipiteistä.

Viittaus Promise-spesifikaation monadittomuuteen, mainitaan myös alempana

\subsection{Funktionaalisen ohjelmoinnin ripottelu}

TODO

Idiksiä siitä että juuri otetaan funktionaalisen ohjemoinnin parhaat palat

Youtube videoista konkreettisia esimerkkejä.

Cantarella on mun kanssa samaa mieltä :) "Mitä enemmän paradigmoihin liittyviä näkemyksiä käsitteleviin artikkeleihin perehtyy, sen myötämielisemmäksi tulee ajatukselle, että paradigmoja tulisi yhdistellä vapaammin"  \cite[45]{cantarella_fp_haitat}

\section{Funktionaalinen ohjelmointi \& Typescript}


\begin{code}
	\begin{minted}{javascript}
function rnd(min, max) { 
	return Math.floor(Math.random() * max) + min;
}
const rnd2 = (min, max) => Math.floor(Math.random() * max) + min;
const rnd3 = min => max => Math.floor(Math.random() * max) + min;



\end{minted}
	\caption{Kolme eri tapaa kirjoittaa funktio JavaScriptissä \cite{okhravi-g-discussion}. Funktiomäärittely, funktioilmaus ja osittain sovellettava funktioilmaus}
	\label{code:javascript_function_types}
\end{code}


TODO

Typescriptiä tullaan käyttämään insinöörityön koodiesimerkeissä, niin on aiheellista näyttää miten Typescriptissä \gls{fp} näkyy.

TODO TypeScript tyypit HYVÄ! Rich Hickey tykkää myös, voi tehä "product type" tms

Toisaalta TS -> overhead, välillä joutuu kikkailemaan

On huomattu, että JavaScript koodia kirjoittaessa voi olla vaikeaa pysytellä puhtaan funktionaalisen ohjelmoinnin raameissa, ja että usein olisi mielletysti helpompaa toteuttaa imperatiivisia ratkaisuja \cite[44]{cantarella_fp_haitat}.  LOLOL :D tää on just miks fp good

\subsection{Promise-tietorakenne ja osittaismonadisuus}

Promise ei ole monadi :( \cite{read-it-later-11481,promises-spec-94}

Se ei ole monadi, koska \gls{js} spesifikaatiota määriteltäessä ei päästy yhteisymmärrykseen siitä, että Promise-tietorakenteen tulisi olla monadi. Syy on moniuloitteinen, mutta pääasiallisesti sivuaa sitä, että funktionaalinen ohjelmointi ja sen käsitteet ovat vaikeita selittää kohtuullisella tarkkuudella. \citep{promises-spec-94}

Tämä kirjoitushetkellä jo yli kymmenen vuotta sitten tehty päätös heikensi merkittävästi \gls{js}:n mahdollisuuksia viedä funktionaalista ohjelmointia eteenpäin. \Gls{js} kielenä on laajuudeltaan ongelmallinen. Uusia ominaisuuksia ei voi lisätä, jos vastaavanlaisia ominaisuuksia on aiemmin ollut osana suosittuja \gls{js}-kirjastoja \cite{proposal-joint-iteration,prototype_library_trends}.

TODO lisää siitä että ei tulla ikinä saamaan "builtin" monadeja
TODO myös että no mitä se tarkoittaa, onko juuri promisen kannalta mitään merkitystä

\subsection{Ramda.js}

Koska funktionaalisen ohjelmakoodin tuottaminen \gls{js} tai \gls{ts} ympäristössä enemmän tai vähemmän vaatii jotain kirjastoa, joko itse ohjelmoitua tai ulkoista, niin tähän insinöörityöhön on kirjastoksi valittu Ramda.js.

Ramda.js, ja kirjaston taustalla oleelinen Fantasy Land -algebrallinen spesifikaatio, ovat kirjastoja jotka pyrkivät johdonmukaiseen funktionaaliseen ohjelmointiin JavaScriptissä. Näiden kirjastojen kehittäjistöstä löytyy samoja henkilöitä jotka aikoinaan pyrkivät saamaan Promise-tietorakenteen virallisesti monadiseksi \cite{ramda:contributors,fantasy-land:contributors,promises-spec-94}. Näyttää siltä, että kun tähän tavoitteeseen ei päästy, päättivät kehittäjät tuoda funktionaalisen ohjelmoinnin JavaScriptiin omin keinoin.

TODO miten ramda toimii

TODO miten ramda sopii omien funktioiden kanssa

TODO miten typescript? ei hyvä, tyypit ovat mitä sattuu (kokemuspohjaisesti)

\subsection{Rajoitteet}

TODO

Mitkä asiat eivät ole mahdollisia, tai mitkä ovat erittäin hankalia / järjettömiä kun ohjelmoidaan \gls{fp} koodia \gls{ts}-maailmassa.


\section{Vertailu yhteenvetona}

TODO

Ehkä nopea yhteenveto että mikä on täysin \gls{fp} ominaista ja mikä ei. Mahdollisesti jokin kiva taulukko.