% Introduction

\chapter{Johdanto}

TODO

\section{Motivaatio}

\glsdisp{functional_programming}{Funktionaalisen ohjelmoinnin} rooli ohjelmistokehityksessä on kasvanut viime vuosina. Kuitenkin siitä, mitä funktionaalisen ohjelmoinnin pitäisi olla ja miten sitä tulisi käyttää, ei tunnu olevan yksimielisyyttä, mikä johtaa ristiriitaisiin näkemyksiin ja keskusteluihin aiheesta.

Tiukasti funktionaaliseen ohjelmointiin tarkoitetut kielet eivät tunnu saavan nostetta alleen päästäkseen yleiseen suosioon (Kuva \ref{fig:fplangpopularity}).  Toisaalta muuten funktionaalisen ohjelmoinnin keinoja on ripoteltu muuten osaksi \glsdisp{imperative_programming}{imperatiivisia-} sekä \glsdisp{object_oriented_programming}{olio-ohjelmointikieliä}.

\begin{figure}[htbp]
    \pgfplotstableread[col sep=comma]{data/fp_lang_popularity.csv}\datatable
    \pgfplotstablegetrowsof{\datatable}
    \pgfmathtruncatemacro{\rows}{\pgfplotsretval-1}
    \centering
    \begin{tikzpicture}
        \begin{axis}[
                width=\linewidth,
                height=8cm,
                ylabel={Suosio},
                xlabel={Vuosi},
                xtick={0,12,...,\rows},
                xticklabel style={rotate=45, anchor=east},
                xticklabels={2004, 2005, 2006, ..., 2024},
                legend pos=north west,
                grid=major,
                cycle list name=color list
            ]
            \addplot [mark=none, color=blue] table [x expr=\coordindex, y=Erlang] {\datatable};
            \addplot [mark=none, color=red] table [x expr=\coordindex, y=Haskell] {\datatable};
            \addplot [mark=none, color=green] table [x expr=\coordindex, y=OCaml] {\datatable};
            \addplot [mark=none, color=orange] table [x expr=\coordindex, y=Elixir] {\datatable};
            \addplot [mark=none, color=purple] table [x expr=\coordindex, y=Scala] {\datatable};
            \legend{Erlang, Haskell, OCaml, Elixir, Scala}
        \end{axis}
    \end{tikzpicture}
    \caption{Funktionaalisten ohjelmointikielien Erlangin, Haskelin, OCamlin, Elixirin ja Scalan suosiokehitys vuosina 2004–2024. Kielet eivät ole olleet huomattavassa nousussa. \cite{fplanggoogletrend}.}
    \label{fig:fplangpopularity}
\end{figure}

Esimerkiksi Java 8 lisätyt lambdat \cite{oracle_function_package} ja Stream-API \cite{oracle_stream_api} ovat suoraan tyyliltään omaksuttua funktionaalista ohjelmointia. JavaScriptissä Array-metodit, kuten \mintinline{javascript}{Array.prototype.map} \cite{mdn_array_map}, \mintinline{javascript}{Array.prototype.filter} \cite{mdn_array_filter} ja \mintinline{javascript}{Array.prototype.reduce} \cite{mdn_array_reduce}, ovat vakiintuneet keskeisiksi työkaluiksi. \gls{js} Set-tietorakenne on juuri saamassa joukko-opille ja funktionaaliselle ohjelmoinnille olennaisia metodeja kuten \mintinline{javascript}{Set.prototype.union} \cite{mdn_set_union} ja \mintinline{javascript}{Set.prototype.difference} \cite{mdn_set_intersection}, jotka myös palauttavat uusia Set-tietorakenteita aiempien muokkaamisen sijaan \cite{mdn_set_methods}.

Myös kirjoitushetkellä tason 3 TC39 esitys \gls{js} iteraattorien apumetodeille vahvistaa funktionaalista tapaa ohjelmoida \cite{tc39_iterator_helpers}. Odotan itse näitä metodeja varsin suurella mielenkiinnolla.

\subsection{Kokemukset}


Opintojen ohessa tieto- ja viestintätekniikan insinööriksi, olen työskennellyt ohjelmistokehittäjänä tuoteohjelmistoyrityksessä, jossa käytetään paljon käytänteitä, jotka mielletään perityvän funktionaalisesta ohjelmoinnista. Nämä käytänteet eivät kuitenkaan ole pakotettuja, vaan ohjelmistokehittäjät ovat voineet valita koodityylinsä suhteellisen vapaasti. Kuitenkin koodikatselmuksissa ja muissa keskusteluissa on usein kuullut lauseita kuten \textquote{tähän olisi voinut käyttää koostefunktiota} tai \textquote{voit halutessasi käyttää funktionaalista ohjelmointityyliä, kun se sopii tilanteeseen}.

Ennen työpaikallani aloittamista tiesin funktionaalisesta ohjelmoinnista lähinnä sen, että sillä on vahva matemaattinen perusta, ja että siinä pyritään kuvailemaan ohjelman toiminta (\glsdisp{declarative_programming}{deklaratiivinen ohjelmakoodi}) suorien käskyjen sijaan (imperatiivinen ohjelmakoodi). Myöskin oli vahva ajatus siitä, että funktionaalinen ohjelmointi olisi täysin eri maailmassa ja uudella tasolla olio-ohjelmointiin tai muuten imperatiiviseen ohjelmointiin verrattuna.

Työpaikalla oppimani käsitys funktionaalisesta ohjelmoinnista laajeni ja muuttui. Siitä tuli enemmänkin tapa rakentaa ja käyttää uudelleenkäytettäviä koodipalikoita eli funktioita.

Koostefunktiot, joissa funktioita suoritetaan toinen toisensa jälkeen antaen aina edellisen tuloste seuraavan syötteeksi tuntuivat mullistavalta. Koodi dokumentoi itse itseään, kun kaikki ohjelman vaiheet ovat selkeästi nimetyissä palikoissa, ettei erillisiä kommentteja tarvitse edes lisätä. Miksei tätä oltu käsitelty millään luennolla?

Kuitenkin työpaikalla funktionaalisen ohjelmoinnin suosio oli varsin polarisoitunutta. Kiinnostukseni funktionaalista ohjelmointia kohtaan kasvoi.

Funktionaalisen ohjelmoinnin taustalla oleva teoria on kiehtovaa, perustavanlaatuista ja luotettavaa. Matematiikka ei valehtele. Funktionaalisen ohjelmakoodin kirjoittaminen on mieluisaa, tuntuu \textquote{fiksulta} ja \textquote{oikealta}. Tunnepohjainen perustelu on totta kai sallittavaa, mutta se ei välttämättä vielä vakuuta muita suuntaan tai toiseen. Kaikki eivät pidä funktionaalista ohjelmointia totuutena ja keinona, millä ratkaista kaikki ongelmat. Olen kuullut paljon perusteltuja mielipiteitä vahvasti \glslink{functional_programming}{funktionaalisen ohjelmoinnin paradigman} puolesta kuin myös vastaan.

Luettavuus, tehokkuus ja ylläpidettävyys ovat kolme keskeistä osa-aluetta, joita on painotettu eniten työpaikalla käydyissä keskusteluissa, kun on arvioitu funktionaalisen ohjelmointitavan hyötyjä. Nämä osa-alueet ovat olleet merkittäviä myös muiden ohjelmointityylien arvioinnissa. Luettavuutta on yleensä pidetty kaikkein tärkeimpänä. Ohjelmakoodin ei tarvitse olla tehokasta ennen kuin optimointia todella tarvitaan \cite{prematureoptimization}, ja ylläpidettävyyden perusta on vahvasti sidoksissa siihen, kuinka luettavaa koodi on.

Kun yritin selittää veljelleni (jolla ei ole ohjelmointitaustaa) aihepiiristä, mitä haluaisin insinöörityössäni tutkia, hänen reaktionsa oli: \textquote{Mitä tarkoitat funktionaalisella koodilla, ai sitä että se toimii?} Kommentti sai minutkin havahtumaan termiin. Vaikka en ehkä vielä ole kovin kokenut jakamaan filosofisia ajatuksia ohjelmointityyleistä, on varmaa, että toivoisin kaikkien pyrkivän kirjoittamaan toimivaa, tai toisin sanoen funktionaalista, ohjelmakoodia.

\subsection{Lähestymistapa}

Tässä insinöörityössä haluan tutkia, mitä tapahtuu, kun funktionaalista ohjelmointia ripotellaan proseduraaliseen ohjelmakoodiin. Keskityn erityisesti siihen, millaisia haasteita ja haittoja syntyy, kun funktionaalinen abstraktio ei noudata Djikstran ajatusta: \textquote{Purpose of abstracting is not to be vague, but to create a new semantic level in which one can be absolutely precise} \cite{dijkstra_humble_programmer}. Tarkastelen tätä ongelmaa sellaisen ohjelmointikielen näkökulmasta, jota ei ole suunniteltu erityisesti funktionaaliseen ohjelmointiin, mutta jossa se on mahdollista. Tämä kieli on \gls{js} (ja \gls{ts}). Valitsin tämän kielen, koska kokemukseni ja osaamiseni painottuvat siihen, ja myös siksi, että kieli on markkinoiden käytetyimpiä. \Gls{js} on myös kielenä siitä mielenkiintoinen, että se mahdollistaa miltei minkälaisten abstraktioiden rakentamisen tahansa helposti ilman suurta vaivaa ohjelmoijalta, mikä johtaa helposti liialliseen kikkailuun ja epäjohdonmukaisuuteen.

Tarkoituksena on löytää mieluisampi määritelmä sille, mitä on funktionaalinen ohjelmointi, miten sitä kannattaa käyttää ja että onko syytä siirtyä suoraan pohjimmiltaan funktionaalisiin ohjelmontikieliin ohjelmointikielistä, joissa ohjelmointitapa on vain tuettu, muttei vaadittu. Kun jotain ei vaadita, se jää usein tekemättä tai ainakin puutteelliseksi.

