% Material and Methods
%\clearpage%if the chapter heading starts close to bottom of the page, force a line break and remove the vertical vspace
\vspace{21.5pt}
\chapter{Empiirinen tutkimus}

Tässä osassa pyritään esittämään kaikista oleellisin, mitä funktionaalisella ohjelmoinnilla voidaan saada aikaan. Teoreettisen perustan ja kokemusten avulla tuodaan esille mitä funktionaalinen ohjelmointi on koetusti parhaimmillaan.

Ajatuksena on, että kun ohjelma on mallinnettu oikein, ei ole suurta merkitystä ohjelmoidaanko olio-ohjelmointia, vai funktionaalista ohjelmointia. Olio-ohjelmoinnissa mallinnus saatettaisiin hoitaa rajapinnoilla (interface). Funktionaalisen ohjelmoinnin tapa mallintaa on käyttää tyyppejä ja abstrakteja tietorakenteita.

Käydään myös miten funktionaalinen ohjelmointi näkyy konkreettisesti. Tämä on erinäköisten funktioiden muodossa.

// TÄSSÄ OLI VÄLIOTSIKOT "Tutkimuksen lähtökohdat", "Tutkimusympäristö", "Tutkimusmenetelmät", ja "Tutkimuksen rajoitukset"
// NE ON POISTETTU TURHAN TOISTON VÄLTTÄMISEKSI
// AJATUKSENA ON KIRJOITTAA ENEMMÄN "RETROSPEKTIIVISESTI", MISTÄ NÄKÖKULMASTA "Empriirinen tutkimus" -OSA TEHTIIN SEURAAVASSA OSASSA "Tulosten analyysi"


\section{Opi kerran, käytä kaikkialla}

Funktionaalisessa ohjelmoinnissa etsitään yleisiä teemoja, ja viedään toistuvia malleja funktioiksi, jotta voidaan syntaksin sijasta kirjoittaa funktioiden nimiä. Olio-ohjelmoinnissa, tai muuten imperatiivisessa ohjelmoinnissa, for-silmukalla toteutettavat algoritmit yleistetään funktioiksi (Kuva \ref{fig:ramdacmds}). Onko helpompaa opetella ääretön määrä funktioita, vai yksi kielirakenne: for-silmukka?

\begin{figure}[ht]
    \centering
    \[
        \begin{array}{rl}
            \left.
            \begin{array}{l}
                filter, without, find, findIndex, findLast, findLastIndex \\
                map, mapIndexed, mapIndexedRight, chain, concat, zip      \\
                reduce, reduceRight, scan, partition, uniq, forEach       \\
                slice, drop, take, dropWhile, takeWhile, zip, zipWith     \\
                all, any, none
            \end{array}
            \right] \quad \text{for loop}
            \\
        \end{array}
    \]
    \caption{Ramda.js kirjaston funktioita listojen käsittelyyn ohjelmoinnissa \cite{ramda:docs}. Kaikki nämä voidaan korvata for-silmukoilla imperatiivisessa paradigmassa.}
    \label{fig:ramdacmds}
\end{figure}

Nimet ovat syntaksiriippumattomia. Samoja nimiä voi käyttää ohjelmointikielestä riippumatta. Nimillä voi kuvata oikean maailman asioita. Siksi voi perustella, että kun tietyn logiikan aina laittaa tietyn nimen taakse funktioksi, ymmärtää sen aina vaikka ohjelmointikieli vaihtuisi. Jos muistaa idean, ei implementaation yksityiskohdilla ole merkitystä.

Jos asia on tarpeeksi monimutkainen ja sen piilottaa nimen taakse, hyötyarvon määrittäminen voi olla haastavaa. Mitä monimutkaisempaa asiaa yritetään enkoodata yksittäiseen nimeen, sitä vaikeampaa se on lukijan ymmärtää, ja myös sitä vaikeampaa sille on löytää uudelleenkäyttötilanteita. Pienikin nyanssiero funktion implementaatiossa totuttuun implementaatioon voi mitätöidä opitun hyödyn eri ympäristöissä.

Yksinkertaisiakin funktioita voi olla vaikea hahmottaa koodista. Mikään ei pakota ohjelmoijaa nimeämään funktiota samalla tavalla kuin miten sama funktio on nimetty jossain toisessa projektissa tai ohjelmointikielessä. Vaikka ohjelmoija tahtoisi noudattaa aiempia nimeämiskäytänteitä, niin aiempia nimeämiskäytänteitä voi olla vaikea löytää, tai ylipäätään jo useita.

Kannattanee käyttää ohjelmointikielen sisäänrakennettuja funktioita, ja metodeja aina kun mahdollista. Näin voi maksimoida sen, että koodi ymmärretään. Jos kyse on jostakin projektin sisäisestä kirjastosta, voi olla hyödyllistä lisätä funktiolle kommentti, jos se tunnetaan muissa ohjelmointiympäristöissä jollain toisella nimellä.

Jos on kyse jostain toimintaympäristökohtaisesta funktiosta, eikä perustavanlaatuisesta yleispätevästä funktiosta, on tärkeää, että funktio nimetään mahdollisimman kuvaavasti. Esimerkiksi sen sijaan, että nimeää funktion nimellä \textcite{processUsers}, voi miettiä tarvitseeko funktion kutsupaikoissa ymmärtää enemmän siitä mitä funktio tekee? Jos kontekstista on selvää, mitä funktio tekee, nimen voi jättää sellaiseksi kuin on. Jos konteksti ei avaa toimitaa enemmän, \textcite{processUsers} on erittäin ympäripyöreä nimi.

\section{Yhdistetyt funktiot}

TODO

\section{Puhtaiden funktioiden hinta}

Pitää pitää mielessä ohjelmointikieli, jossa toimitaan. Säännöt tulee sopeuttaa ympäristöön. Vaikka funktionaalisessa ohjelmoinnissa pyritään olla mutatoimatta dataa, tästä ei missään nimessä ole pakko pitää kiinni kynsin hampain.

Joissain ohjelmointikielissä, tai ohjelmointikielien kirjastoissa, muuttumattomien tietorakenteiden käyttäminen on saatu varsin tehokkaaksi. Näin ei kuitenkaan ole asian laita JavaScriptissä, tai ohjelmointikielissä yleisesti. Yleisesti ottaen tiedon mutatointi on nopeaa ja kopiointi hidasta. Näin ollen, jos kirjoitetaan funktioita, jotka palauttavat aina uusia kopioita, vanhojen mutatoimisen sijasta, saadaan usein hidasta ja tehotonta ohjelmakoodia.

Jossain vaiheessa ohjelman suoritusta tietokoneen bitit kääntyilevät nollista ykkösiin. Näin tietokoneet toimivat \cite{is_reduce_bad}. Tämän vuoksi mutaatiota ei kannata pelätä, kunhan sen hoitaa asianmukaisesti.

Jos funktio mutatoi ainoastaan muuttujia, joita se itse luo funktion ajon ajaksi, ei sillä ole lopputuloksen kannalta toiminnallista merkitystä. Kuitenkin tehokkuusvoitot voivat olla huomattavat versioihin, joissa mutatointia ei harjoiteta.

Esimerkkinä funktio, joka ottaa sisään listan avain-arvo-pareja, ja luo niistä olion. Näytetään kaksi (funktionaalista) tapaa totettaa funktio.
Versio, joka ei mutatoi muuttujia missään vaiheessa (Koodiesimerkki \ref{code:js_just_mutate_immutable}), ja versio, joka mutatoi vain itse luomiaan muuttujia (Koodiesimerkki \ref{code:js_just_mutate_mutable}).

Tarkkailijan näkökulmasta molemmat funktiot ovat kuitenkin puhtaita.

\begin{code}
    \begin{minted}[highlightlines={8,14}]{javascript}
const entries = Array.from({ length: 1000 }, (_, i) => [
    `key-${i}`,
    `value-${i}`
])

const objectFromEntries = (entries) =>
    entries.reduce((acc, entry) => {
        return { ...acc, [entry[0]]: entry[1] }
    }, {})

console.time('Immutable')
objectFromEntries(entries)
console.timeEnd('Immutable')
// Immutable: 112.718017578125 ms
\end{minted}
    \caption{Funktio, joka ottaa listan avain-arvo-pareja ja luo niistä olion. Olion luonnissa ei käytetä ollenkaan mutatointia.}
    \label{code:js_just_mutate_immutable}
\end{code}

Täysin mutatoimattomalla versiolla kesti luoda tuhannesta avaimesta olio yli 300 kertaa kauemmin, kuin versiolla, joka mutatoi kohtuudella.


\begin{code}
    \begin{minted}[highlightlines={8,15}]{javascript}
const entries = Array.from({ length: 1000 }, (_, i) => [
    `key-${i}`,
    `value-${i}`
])

const objectFromEntries = (entries) =>
    entries.reduce((acc, entry) => {
        acc[entry[0]] = entry[1]
        return acc
    }, {})
          
console.time('Mutable')
objectFromEntries(entries)
console.timeEnd('Mutable')
// Mutable: 0.35693359375 ms
\end{minted}
    \caption{Sama funktio kuin aiempi. Ainoa ero, että pareja iteroidessa luotavaa oliota mutatoidaan.}
    \label{code:js_just_mutate_mutable}
\end{code}

Useimmiten ohjelman tehokkuudella ei ole paljoa merkitystä, ja luotettavuus ja luettavuus ovat edellä. Kuitenkin tässä tilanteessa tehokkuuserot ovat niin merkittävät, että jos 1 000 avain-arvo-parin sijasta, oltaisiin käytetty 100 000, tai vaikka 1 000 000 avain-arvo-paria, mutatoimaton versio ei välttämättä olisi suoriutunut tehtävästä koskaan. Näitä määriä yritettiin, mutta suoritukset lopetettiin kesken, kun alkoi näyttämään, ettei tehtävä tosiaan ollut suoriutumassa koskaan.

\section{Ongelmien mallintaminen}

Kuvitellaan, että ollaan rakentamassa rajapintaa verkossa toimivalle tietovisa / koe -alustalle.

Yksi tietovisa koostuu useasta monivalintakysymyksestä. Tietovisaa voisi lähteä mallintamaan seuraavasti.

\begin{code}
    \begin{minted}{typescript}
type Question = {
  question: string
  answers: Array<string>
  correctAnswerIndices: Array<number>
}

type Quiz = {
  description: string
  questions: Array<Question>
}
         
\end{minted}
    \caption{Mahdollinen lähestymistapa yksinkertaiselle tietovisan mallinnukselle}
    \label{code:ts_first_quiz}
\end{code}

Yksinkertaisen tietovisan saisi toimimaan kyseisellä mallilla. Yksi kysymys tukee jopa montaa oikeaa vastausta.
Mallintamisessa on kuitenkin ongelma. Se valehtelee. Sillä voidaan kuvata tiloja, joiden pitäisi olla mahdottomia.

\textbf{Listat voivat olla tyhjiä.} Malli ei pidä huolta, että tietovisassa on yhtäkään kysymystä. Malli ei pidä huolta, että kysymyksessä on yhtään vastausta, eikä että on olemassa yhtään oikeaa vastausta. Tämä johtuu siitä, että \mintinline{typescript}|Array|-tietorakenne voi olla tyhjä.

Vastauksena on luoda tyyppi listalle, joka ei voi olla tyhjä (Koodiesimerkki \ref{code:ts_non_empty}).

\begin{code}
    \begin{minted}{typescript}
type NonEmptyArray<T> = {
    first: T
    rest: Array<T>
}
    \end{minted}
    \caption{Mahdollinen lähestymistapa yksinkertaiselle tietovisan mallinnukselle}
    \label{code:ts_non_empty}
\end{code}

Tyypissä on käytetty tyyppimuuttujaa T. Jos geneeriset tyypit eivät ole tuttuja, tyyppimuuttuja tarkoittaa sitä että sen sijalle voi laittaa mitä tahansa. Kyse on myös parametrisestä polymorfista (parametric polymorphism).

Pääasia on, että tyyppi kuvaa listaa, joka ei voi olla tyhjä. Tyypillä on kenttä \mintinline{javascript}|first|, jonka on oltava olemassa. Ja kenttä \mintinline{javascript}|rest|, jossa säilytetään listan loput alkiot. Kentän lista on taas tavallinen \mintinline{javascript}|Array|, ja se voi, ja saa olla, taas tyhjä (Esimerkkikoodi \ref{code:ts_non_empty_quiz,spec}).


\begin{code}
    \begin{minted}[highlightlines={3,4,9}]{typescript}
    type Question = {
      question: string
      answers: NonEmptyArray<string> 
      correctAnswerIndices: Array<number>
    }
    
    type Quiz = {
      description: string
      questions: NonEmptyArray<Question> 
    }
             
    \end{minted}
    \caption{Toinen lähestymistapa tietovisan mallintamiselle, jossa käytetään itsemääritettyä NonEmptyArray-tyyppiä}
    \label{code:ts_non_empty_quiz}
\end{code}

Nyt tietovisassa on oltava vähintään yksi kysymys, ja jokaisella vähintään yksi mahdollinen vastaus. Kuitenkin oikeita vastauksia ei ole välttämättä ainuttakaan, sillä kenttä \mintinline{typescript}|correctAnswerIncides| on edelleen tyypiltään \mintinline{typescript}|Array<number>|.

Tämä on selkeästi parannus. Tyyppijärjestelmä pitää huolen, että mallia seurataan. Tarkastuksia tyhjyydestä ei tarvitse tehdä if-lauseilla. Malli ei kuitenkaan ole vieläkään täydellinen.

\textbf{Kenttien arvot voivat olla mitä tahansa.} Mikään ei pidä huolta, että esimerkiksi kentän \mintinline{typescript}|correctAnswerIncides| indeksit ovat oikeellisia. Myös kaikki, joissa tyyppinä on \mintinline{typescript}|string| voivat ottaa vastaan mitä tahansa merkkijonoja. Myös tyhjiä merkkijonoja.

Merkkijonojen validointi TypeScriptin tyyppijärjestelmässä on kuitenkin hieman vaivalloista, eikä välttämättä tarpeellista. Kenttä \mintinline{typescript}|correctAnswerIncides| on kuitenkin ajatuksena erittäin huono, sillä malli ei millään tavalla määrittele miten se liittyy kysymykseen tarkemmin. Mikään ei estä laittamasta täysin päättömiä numeroita \textcite{oikeiksi} indekseiksi. Korjauskeinona on paras keino: kentän poistaminen.

Kentän voi poistaa kokonaan, jos mallinnusta viedään pidemmälle. Voidaan sopia, että on olemassa kahdenlaisia vastauksia. Oikeita tai vääriä. Tämä on varsin helppo mallintaa (Koodiesimerkki \ref{code:ts_answer_types})

\begin{code}
    \begin{minted}{typescript}
type CorrectAnswer = {
    type: "correct"
    answer: string
}
type IncorrectAnswer = {
    type: "incorrect"
    answer: string
}
    \end{minted}
    \caption{Oikeille ja väärille vastauksille omat tyypit}
    \label{code:ts_answer_types}
\end{code}

Uusilla tyypeillä voidaan mallintaa kysymyksiä oikeellisemmin. Voidaan myös määrittää, että kysymyksellä on oltava vähintään yksi oikea vastaus, ja nolla tai useampi väärä vastaus (Koodiesimerkki \ref{code:ts_question_with_explicit_answer_types}).

\begin{code}
    \begin{minted}[highlightlines={3,4}]{typescript}
type Question = {
    question: string
    correctAnswers: NonEmptyArray<CorrectAnswer>
    incorrectAnswers: Array<IncorrectAnswer>
}
    \end{minted}
    \caption{Kysymykseen voi tarkentaa millaisia vastauksia hyväksytään}
    \label{code:ts_question_with_explicit_answer_types}
\end{code}

Malli ei enää valehtele. Voi kuitenkin olla, että tulevaisuudessa on tarve luoda enemmän vaatimuksia. Voidaan haluta rajoittaa, että kysymyksessä voi valita vain yhden vaihtoehdon, tai usean. Voidaan haluta antaa mahdollisuus antaa vastauksena vapaata tekstiä. Tai mitä ikinä.

Tämänkään kaltaisessa tapauksessakaan ei kannata unohtaa, että hyvä malli ei valehtelee. \textbf{Voidaan käyttää hyväksi summatyyppejä.} Sen sijasta, että lisättäisiin tyyppeihin uusia kenttiä kuten \mintinline{javascript}|isMultipleAnswerQuestion| tai \mintinline{javascript}|isFreeForm|, voidaan puolestaan luoda jokaiselle fundamentaalisesti erilaiselle asialle yksinkertaisesti kokonaan oma tyyppinsä, ja yhdistää ne yhdeksi summatyypiksi.

\begin{code}
    \begin{minted}[highlightlines={20}]{typescript}
type MultipleAnswerQuestion = {
    type: "multipleAnswerQuestion"
    question: string
    correctAnswers: NonEmptyArray<CorrectAnswer>
    incorrectAnswers: Array<IncorrectAnswer>
}

type SingleAnswerQuestion = {
    type: "singleAnswerQuestion"
    question: string
    correctAnswer: CorrectAnswer
    incorrectAnswers: Array<IncorrectAnswer>
}

type FreeFormQuestion = {
    type: "freeFormQuestion"
    question: string
}

type Question = MultipleAnswerQuestion | SingleAnswerQuestion | FreeFormQuestion
    \end{minted}
    \caption{Kysymysten mallintaminen summatyypillä}
    \label{code:ts_sum_type_nice}
\end{code}

Malli ei enää valehtele. Todellisuutta mallintavilla malleilla saadaan luotettavampaa koodia, ja poistetaan turhia if-lauseita. Myös jos mallista poistetaan mahdottomat tilat, niitä ei tarvitse edes testata.

\subsection{Virheet mukaan mallintamiseen}

Ohjelmissa tapahtuu virheitä. Vaikka pyrittäisiin malleihin, joista on poistettu mahdottomat tilat, niin ohjelmia ajaessa voidaan silti törmätä virheisiin.

Miten on hyvä mallintaa tilanteita, kun virheitä tapahtuu?

Yleisesti imperatiivisissa paradigmoissa virhetilanteissa metodit ja funktiot palauttavat null-arvoja, virheitä tai poikkeuksia.
Funktionaalisessa ohjelmoinnissa voidaan käyttää samoja keinoja, mutta useimmin funktioiden suorituksen räjäyttämisen sijasta funktiot palauttavat summatyyppejä, tai monadeja, joissa voi olla sisällä joko oikea palautus- tai virhetyyppi.

TypeScriptissä yksinkertaisimmillaan tämän voi toteuttaa yhdellä omalla tyypillä (Koodiesimerkki \ref{code:ts_null_sum}).

\begin{code}
    \begin{minted}{typescript}
type Maybe<T> = T | null
const mightWorkMightNot = (): Maybe<string> => {
    if (Math.random() > 0.5) {
        return null
    }
    return "hello world"
}
    \end{minted}
    \caption{Mahdollisesti puuttuvan paluuarvon malli}
    \label{code:ts_null_sum}
\end{code}

Deklaratiivisesti funktio kertoo, että se saattaa palauttaa merkkijonon, tai saattaa olla palauttamatta. Ehkä se on merkkijono, ehkä se ei ole.
Tyypin käyttäminen on hieman tönkköä, sillä jos funktion oikea palautusarvo on null, on mahdotonta sanoa oliko funktiokutsu onnistunut vai ei.

Tyypin voi viedä pidemmälle, jos arvot kääritään objekteihin. Vaihdetaan nimi Result-tyypiksi, että tyyppi voi kapseloida myös virheitä. (Koodiesimerkki \ref{code:ts_better_result_sum}.)

\begin{code}
    \begin{minted}{typescript}
type Success<T> = { value: T }
type Failure = { error: Error }
type Result<T> = Success<T> | Failure 

const mightWorkMightNot = (): Result<string> => {
    if (Math.random() > 0.5) {
        return { error: new Error("Sorry, bad failure.") }
    }
    return { value: "hello world" }
}
    \end{minted}
    \caption{Vaihtoehtoinen malli mahdollisesti epäonnistuvalle paluuarvolle}
    \label{code:ts_better_result_sum}
\end{code}


Result-tyyppi on objekti, jolla on joko kenttä \mintinline{typescript}|value| tai \mintinline{typescript}|error|.

Näin Result-tyyppi voi sisältää myös arvon \mintinline{typescript}|null|, sillä Result-objektin tarkan tyypin voi nyt päätellä ilman sitä. Nyt tarkan tyypin voi määrittää \mintinline{typescript}|value| tai \mintinline{typescript}|error| kentän läsnäolosta tai puutteesta. Näin rakennettuna tyypille on myös helppo rakentaa apufunktioita, joilla selvitetään, onko paluuarvo onnistunut, vai ei. Voi myös luoda apufunktiot, joilla luoda Result-objekteja. (Koodiesimerkki \ref{code:result_helpers}).

\begin{code}
    \begin{minted}{typescript}
const isFailure = <T>(x: Result<T>): x is Failure => "error" in x
const isSuccess = <T>(x: Result<T>): x is Success<T> => !isFailure(x)
const failureUnit = (error: string): Failure => ({ error: new Error(error) })
const successUnit = <T>(value: T): Success<T> => ({ value })
    \end{minted}
    \caption{Apufunktioita Result-tyypin käyttöön TypeScriptissä}
    \label{code:result_helpers}
\end{code}

Näillä voidaan rakentaa yhdistettyjä funktioita, joissa paluuarvon luonti ja palauttaminen on eksplisiittistä ja selkeää. Koodiesimerkissä \ref{code:result_pipe_example} käsitellään Result-objekteja yhdistetyssä funktiossa.

\begin{code}
    \begin{minted}{typescript}
const helloMaybe = (): Result<string> => {
    if (Math.random() > 0.5) {
        return failureUnit("Sorry, bad failure.")
    }
    return successUnit("hello world")
}

const addExclamation = (x: Result<string>): Result<string> => {
    if (isFailure(x)) return x
    return successUnit(x.value + "!")
}

const toUpperCase = (x: Result<string>): Result<string> => {
    if (isFailure(x)) return x
    return successUnit(x.value.toUpperCase())
}

pipe([
    helloMaybe,
    addExclamation,
    toUpperCase
])()
// Palauttaa { value : "HELLO WORLD!}
// tai { error: Error("Sorry, bad failure.") }
    \end{minted}
    \caption{Esimerkki yhdistetystä funktiosta Result-tyypin kanssa.}
    \label{code:result_pipe_example}
\end{code}

Result-tyypin käyttö on selkeää, ja TypeScriptillä on pakko tarkistaa, onko arvo \mintinline{typescript}|Success| vai \mintinline{typescript}|Failure|, ennen kuin sen käärittyä arvoa voi tarkastella tai muokata.

Jos yksikin funktio palauttaa Result-objektin, jossa on virhe, objekti kulkee muuttumattomana loppujen funktioiden lävitse.

Kuitenkin ongelma on, että tämänkaltaisena Result-tyypin käyttäminen on loppujen lopuksi vain syntaksisokeroitu null-arvon tarkistus. Ne if-lauseet, joita aiemmin poistettiin todenmukaisella tyyppimallinnuksella, ovat tulleet takaisin aina pakollisen tarkistamisen muodossa.

Result-tyypillä on kuitenkin jotain, jolla sen voi viedä vielä askelta pidemmälle. Result-tyypin voi toteuttaa monadina.


\subsection{Result-monadi}

TODO

\begin{code}
    \begin{minted}{typescript}
const helloMaybe = (): Result<string> => {
    if (Math.random() > 0.5) {
        return failureUnit("Sorry, bad failure.")
    }
    return successUnit("hello world")
}

const addExclamation = 
    (x: string): Result<string> => successUnit(x + "!")
const toUpperCase = 
    (x: string): Result<string> => successUnit(x.toUpperCase())

helloMaybe()
 .bind(addExclamation)
 .bind(toUpperCase)
\end{minted}
    \caption{Miltä aiemman esimerkin koodi voi näyttää, jos Result toimii kuin monadi.}
    \label{code:result_monad_example}
\end{code}

\subsection{Map, filter, reduce}

Monadit eivät ole pakollisia. Funktori on usein tarpeeksi. Funktori on rakenne, jolla on map-metodi.
