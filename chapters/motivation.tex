% Motivation

\chapter{Motivaatio}

Siitä mitä \glsdisp{functional_programming}{Funktionaalisen ohjelmoinnin} tulisi olla ja miten sitä tulisi käyttää, ei tunnu olevan yksimielisyyttä. Matemaatikot vannovat funktionaalisen ohjelmoinnin oikeellisuuden nimeen, ja pragmaatikot kauhistuvat. Kuuluisan ristiriitaiset ja mutkikkaat keskustelut hämärtävät pohjaa, minkä päälle funktionaalinen ohjelmointi on rakennettu. \citep{stackoverflow_what_monad,stackoverflow:why_monad,promises-spec-94}

Kuitenkin funktionaalista ohjelmointia kutsutaan ilmiselväksi reitiksi ohjelmoida ja esimerkiksi olio-ohjelmointia ylivertaisemmaksi \cite[1]{the_oo_way}. Jopa Robert C. Martin, tunnettu ohjelmointikäytäntöjen asiantuntija ja olio-ohjelmoinnin puolestapuhuja, on siirtynyt merkittävästi funktionaalisen ohjelmoinnin suuntaan \cite{martin2019whyclojure,martin2017pragmaticfp}. Lienee olla tarvetta saada selville miten funktionaalisuutta saataisiin enemmän osaksi nykyohjelmoijan työkalupakkia.

Tiukasti funktionaaliseen ohjelmointiin tarkoitetut kielet eivät tunnu saavan nostetta päästäkseen yleiseen suosioon (Kuva \ref{fig:fplangpopularity}). Ero siirtyessä \glsdisp{object_oriented_programming}{olio-ohjelmoinnista} tai \glsdisp{imperative_programming}{imperatiivisesta ohjelmoinnista} funktionaaliseen ohjelmointiin on kuin yöllä ja päivällä. Siksi funktionaalisen ohjelmoinnin keinoja ripotellaan osaksi suosittuja ohjelmointikieliä, jotka ovat perimmäiseltä filosofialtaan täysin muuta kuin funktionaalinen ohjelmointi. Kenties ajatellaan niin, että varpaat on ensin kasteltava, ennen kuin voi hypätä syvään päätyyn.

\begin{figure}[htbp]
    \pgfplotstableread[col sep=comma]{data/fp_lang_popularity.csv}\datatable
    \pgfplotstablegetrowsof{\datatable}
    \pgfmathtruncatemacro{\rows}{\pgfplotsretval-1}
    \centering
    \begin{tikzpicture}
        \begin{axis}[
                width=\linewidth,
                height=8cm,
                ylabel={Suosio},
                xlabel={Vuosi},
                xtick={0,12,...,\rows},
                xticklabel style={rotate=45, anchor=east},
                xticklabels={2004, 2005, 2006, ..., 2024},
                legend pos=north west,
                grid=major,
                cycle list name=color list
            ]
            \addplot [mark=none, color=blue] table [x expr=\coordindex, y=Erlang] {\datatable};
            \addplot [mark=none, color=red] table [x expr=\coordindex, y=Haskell] {\datatable};
            \addplot [mark=none, color=green] table [x expr=\coordindex, y=OCaml] {\datatable};
            \addplot [mark=none, color=orange] table [x expr=\coordindex, y=Elixir] {\datatable};
            \addplot [mark=none, color=purple] table [x expr=\coordindex, y=Scala] {\datatable};
            \legend{Erlang, Haskell, OCaml, Elixir, Scala}
        \end{axis}
    \end{tikzpicture}
    \caption{Funktionaalisten ohjelmointikielien Erlangin, Haskelin, OCamlin, Elixirin ja Scalan suosiokehitys vuosina 2004-2024. Kielet eivät ole olleet suuressa nousussa. \cite{fplanggoogletrend}.}
    \label{fig:fplangpopularity}
\end{figure}


Ripoittelun voi havaita esimerkiksi kun vahvasti olio-ohjelmointiin sovellettua Javaa on tuotu kohti funktionaalista pelikenttää erinäköisin kielen työkalujen, kuten kuten lambdafunktioiden ja Stream-API:n metodien putkittamisen avulla \cite{oracle_function_package,oracle_stream_api} .
Javaa voikin nykyään jo kutsua hybdridiksi ohjelmointikieleksi funktionaalisen ja olio-ohjelmoinnin väliltä \cite[50]{sundstrom_java_fp}.

Myös JavaScriptissä Array-metodit, kuten \mintinline{javascript}{Array.prototype.map} \cite{mdn_array_map}, \mintinline{javascript}{Array.prototype.filter} \cite{mdn_array_filter} ja \mintinline{javascript}{Array.prototype.reduce} \cite{mdn_array_reduce}, ovat vakiintuneet keskeisiksi työkaluiksi \cite{vakil2016,8_must_know_array_methods}. Kyseiset funktiot ovat laajalti käytössä funktionaalisessa ohjelmoinnissa. Myös \gls{js} Set-tietorakenne on juuri saamassa \glsdisp{set_theory}{joukko-opille} ja funktionaaliselle ohjelmoinnille olennaisia metodeja kuten \mintinline{javascript}{Set.prototype.union} \cite{mdn_set_union} ja \mintinline{javascript}{Set.prototype.difference} \cite{mdn_set_intersection}, jotka palauttavat uusia Set-tietorakenteita aiempien muokkaamisen sijaan funktionaaliselle ohjelmoinnille ominaisesti \cite{mdn_set_methods}.

Myös kirjoitushetkellä tason 3 TC39-esitys \gls{js} iteraattorien apumetodeille vahvistaa funktionaalista tapaa ohjelmoida \cite{tc39_iterator_helpers}. Näiden metodien lisääminen mahdollistaa vielä johdonmukaisemman funktionaalisen koodin kirjoittamista.

\section{Kokemukset funktionaalisesta ohjelmoinnista}


Tehtäessä työtä osana Hoxhunt Oy:n tuotekehitystiimiä on saatu kokemusta funktionaalisesta ohjelmoinnista. Kokemuspohjaista tietoa on kerätty tiimiläisiltä sekä muuten omalta osalta. On nähty kuinka funktionaalisen ohjelmoinnin käytänteitä käytetään, siten että ensin niiden käyttöön on kannustettu, ja toisin pyritty estämään. Koodikatselmuksissa ja muissa keskusteluissa on usein kuultu ajatuksia kärkkäästi niin funktionaalisen ohjelmoinnin puolesta kuin vastaan.

Funktionaalisen ohjelmoinnin kulkakivi on sen matemaattinen perusta \cite{computerphile_lambda}. Toisinaan funktionaalista ohjelmointia on mielletty eräänlaiseksi matemaattisena todistamiseksi, jota humoristisesti ajatellaan vain matematiikan maisterin tutkinnon suorittaneiden taitavan. Voi olla vaikea nähdä funktionaalisen ohjelmoinnin hyötyjä, jos kokee sen ylipäätään vain ylimääräisenä monimutkaisuutena.

Kääntöpuoli on funktionaalisen koodin selittävyys: deklaratiivisuus. Jos on nähty funktionaalisen ohjelmoinnin tuntemattomuuden tai havaitun monimutkaisuuden läpi, niin on löydetty se kuinka funktionaaliset ohjelmat voidaan lukea läpi kuin kirjat. Tämä johtuu siitä, että funktionaalinen ohjelmakoodi on perusteiltaan (\glsdisp{declarative_programming}{deklaratiivista ohjelmakoodia}) suorien käskyjen sijaan (\glsdisp{imperative_programming}{imperatiivinen ohjelmakoodi}) \cite{ms:fp_vs_imperative}.

Koostefunktiot, joissa funktioita suoritetaan toinen toisensa jälkeen, ja annetaan aina edellisen tuloste seuraavan syötteeksi, näyttää suoraan mitä siinä ylätasolla tapahtuu. Koodi dokumentoi itse itseään, kun kaikki ohjelman vaiheet ovat selkeästi nimetyissä palikoissa, ei erillisiä kommentteja tarvitse edes lisätä  (Koodiesimerkki \ref{code:first_pipeline}).

\begin{code}
    \begin{minted}{typescript}
    const nextState = R.pipe(
        handleInput,
        updateTimestamp,
        decreaseMoveTimer,
        handleFall
    )
    
\end{minted}
    \caption{TypeScript-esimerkki funktiokompositiosta käytännönprojektissa. Koodi on osa funktionaalisella tyylillä kirjoitettua Tetris-peliä.}
    \label{code:first_pipeline}
\end{code}


Toisaalta koodin deklaratiivisuuden ylistämisellä voi yrittää peittää muita ongelmia. Jos sokeana seuraa sääntöjä ja käytänteitä, voi jäädä muuten tärkeitä osa-alueita huomioimatta \cite{functional_fixedness}. Jos pyrkii liiallisesti luettavuuteen deklaratiivisella koodilla, voi esimerkiksi ohjelman tehokkuus kärsiä.

Luettavuus, tehokkuus ja ylläpidettävyys ovat kolme keskeistä osa-aluetta, joita painotetaan eniten työpaikalla käydyissä keskusteluissa, kun arvioidaan funktionaalisen ohjelmointitavan laajempia hyötyjä. Nämä osa-alueet näkyvät merkittävinä myös muiden ohjelmointityylien arvioinnissa. Luettavuutta pidetään yleensä kaikkein tärkeimpänä. Ohjelmakoodin ei tarvitse olla tehokasta ennen kuin optimointia todella tarvitaan \cite{prematureoptimization}, ja ylläpidettävyyden perusta on vahvasti sidoksissa siihen, kuinka luettavaa koodi on.

% Kun yritin selittää veljelleni (jolla ei ole ohjelmointitaustaa) aihepiiristä, mitä haluaisin insinöörityössäni tutkia, hänen reaktionsa oli: \textquote{Mitä tarkoitat funktionaalisella koodilla, ai sitä että se toimii?} Kommentti sai minutkin havahtumaan termiin. Vaikka en ehkä vielä ole kovin kokenut jakamaan filosofisia ajatuksia ohjelmointityyleistä, on varmaa, että toivoisin kaikkien pyrkivän kirjoittamaan toimivaa, tai toisin sanoen funktionaalista, ohjelmakoodia.

\section{Lähestymistapa}

Tässä insinöörityössä tutkitaan mitä tapahtuu, kun funktionaalista ohjelmointia ripotellaan proseduraaliseen ohjelmakoodiin. Eritysesti keskitytään siihen, millaisia haasteita ja haittoja voi syntyä, kun funktionaalista ohjelmointia harjoitetaan \gls{ts}-ympäristössä. Tutkitaan mitä käy kun koodin abstraktio ei nosta \glsdisp{correctness}{koodin oikeellisuutta} tai vie mahdollisten väärien tilojen avaruutta pienemmäksi. Näiden on todettu olevan abstraktion ja funktionaalisen ohjelmoinnin tarkoituksia. \citep{dijkstra_humble_programmer,impossiblebetter}

Ongelmaa tarkastellaan sellaisen ohjelmointikielen näkökulmasta, jota ei ole suunniteltu erityisesti funktionaaliseen ohjelmointiin, mutta jossa se on mahdollista. Insinöörityössä pääasialliseksi ohjelmointikieleksi valikoitui \gls{js} (ja \gls{ts}). Kieli valittiin osaamisen ja kokemuksen perusteella ja toisaalta myös siksi, että kieli on markkinoiden käytetyimpiä, ja siten yksi olennaisimmista \cite{pypl:lang}. \Gls{js} on myös kielenä siitä mielenkiintoinen, että se mahdollistaa abstraktiota ilman suurta vaivaa ohjelmoijalta, mikä johtaa helposti hätäilyyn ja epäjohdonmukaisuuteen.

Tarkoituksena on löytää tasapaino sille, miten funktionaalinen ohjelmointi kannattaa ottaa mukaan ohjelmistoprojektiin. Pohjalla on ajatus, että paras tapa olisi vain siirtyä kokonaan funktionaalisiin ohjelmointikieliin hybridikielten sijasta. Tätä ajatusta pyritään kumoamaan, sillä toivotaan, että funktionaalisuus voisi toimia myös kevyemmin osana ohjelmoijan arkea.

Kun jotain ei vaadita, se jää usein tekemättä tai ainakin puutteelliseksi. Siksi voi olla haasteellista ohjelmoida pragmaattista funktionaalista koodia JavaScriptissä; Kielessä, missä juuri mitään sääntöjä ei pohjimmiltaan ole.
